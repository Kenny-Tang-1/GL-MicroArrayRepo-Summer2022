---
title: "Agilent Single-Channel Microarray Processing Pipeline RMarkdown (GLDS-41)"
output: html_document
date: "`r Sys.Date()`"
---

## Installing necessary packages

For processing Agilent microarray data, I needed to install a few packages that were used for the importing and analyzing the data. 
This included Bioconductor as well as Linear Models for Microarray (Limma). These are popular packages for processing microarray data.

```{r}
## For installing Bioconductor on R
# if (!require("BiocManager", quietly = TRUE))
#     install.packages("BiocManager")
# BiocManager::install(version = "3.14")

## For installing limma on R
# if (!require("BiocManager", quietly = TRUE))
#     install.packages("BiocManager")
# BiocManager::install("limma")


```
## Load the packages
After installing the packages above, I had to load them in using the library function so that I could access their functions.
```{r}
library(limma)

```
## Importing the Raw Data
Now that the library was loaded, I was able to import the raw data. I started by importing the runsheet into R.
This contained the necessary data for processing later in the pipeline.
```{r Importing_runsheets}
dir = "C:/Users/tangk/Desktop/Agilent_Microarray"
GLDS_41_rs <- read.csv(file.path(dir, "Runsheet(GLDS-41).csv"), check.names = FALSE, fileEncoding = 'UTF-8-BOM') ## Outputs a dataframe
Factor_Value <- GLDS_41_rs[,"Factor Value[gravity]"]
```
- dir = A variable that stores the location of where I kept the runsheets.
- GLDS_41_rs = A varaible that holds the contents of those runsheets.
- Factor_Value = A variable that holds specifically the factor values column from the runsheet.

Here, I imported the raw data from the text files into R using the readmaimages() function from the Limma package.
```{r Raw_Data_Input} 
datadir = "C:/Users/tangk/Desktop/Agilent_Microarray/input_data"
files = dir(path = file.path(datadir, "GLDS-41/GLDS-41_Raw_Data"), pattern="*\\.txt$")

## Input: ".txt" files, Output: EListRaw (Raw expression levels)
raw_data <- limma::read.maimages(files, source="agilent", path = file.path(datadir, "GLDS-41/GLDS-41_Raw_Data"), sep="\t", green.only = TRUE)
  
```
-   datadir = A variable that stores the path to the directory that holds the three datasets that I have chosen.
-   files = A variable that will detect all of the text files within the GLDS-41_Raw_Data directory. This is where all of the raw Agilent microarray data is stored for the GLDS-41 dataset.
-   source = "agilent" because the data that I want to import will be agilent microarray data. There are other options for this flag for other types of microarrays
-   path = The path to the directory that holds the dataset's raw data.
-   sep = How the data is separated in those raw data files (in our case it's tab separated).
-   green.only = TRUE, This command is for telling the function that it should only read the green (Cys3) channel rather than red and green since we're only looking at single channel microarrays.

## QC of the Raw Data

In this step, I looked at the raw data to make sure that it is in the correct format so that it could be processed correctly down the pipeline.

```{r EListRaw_Density_plot, fig.height = 8, fig.width = 8, fig.align = "center"}
plotDensities(raw_data, log = TRUE, legend = "topright" , main = "EListRaw Densities")
# Add in (potentially)
# Color the lines based on the experimental groups they are in
```

```{r}
## JDO: This is outputting different plots (based on how the function is 'blind' to other columns based on input argument and the 'z-range / saturation values under each plot'), but I agree, they look very similar, maybe use zlim to set a more narrow range, the current zrange printed below each graph gives the actual max and min values. Maybe using 75%*max and 125%*min to start, we lose resolution at the high and low ends but that might be worth the tradeoff for better resolution in the middle
for (sample_name in colnames(raw_data$E)) {
    print(sample_name)
    imageplot(raw_data$E[,sample_name], layout=raw_data$printer, legend = TRUE)
} # Prints out a pseudo image of each sample for visualizing spatial artifacts (manually look for errors in intensities of raw data)
```

```{r fig.height = 5, fig.width = 5, fig.align = "center"}
for (sample_name in colnames(raw_data$E)) {
    ## JDO: you'll need to increment the array argument here to graph each column
    limma::plotMA(raw_data,array=1,xlab="Average log-expression",ylab="Expression log-ratio(this sample vs. others)", main = sample_name, zero.weights = TRUE, status=raw_data$genes$Status)
}
```

```{r}
for (sample_name in colnames(raw_data$E)) {
    ## JDO: you'll need to increment the array argument here to graph each column
    plotFB(raw_data, array = 1, pch = 16, cex = 0.3, xlab = "log2 Background", ylab = "log2 Foreground", main = sample_name) # USe this and loop through it
}
```

## Normalization of the Data
After making sure that the raw data was formatted properly,
I moved on to removing a lot of the variation in the gene expression data
that comes from external sources (i.e. Sample preparation, labeling, hybridization)
by performing normalization on the raw data. For this step, I was able to use another
function from Limma called backgroundCorrect() which took in the raw data and normalized it. 

```{r}
corrected_data <- limma::backgroundCorrect(raw_data, method = "normexp", verbose=TRUE)
# Input: Background corrected EListRaw, Output: Elist
norm_data <- normalizeBetweenArrays(corrected_data, method = "quantile")  
```

## QC of the Normalized Data

```{r}
## JDO: you'll need to increment the array argument here to graph each column
norm_data_plot <- limma::plotMA(norm_data, array = 1, xlab = "Average Log-expression", ylab = "Expression Log-ratio", zero.weights = TRUE)

```

## Differential Gene Analysis

```{r}

```

## Adding Gene Annotations

```{r}

```
