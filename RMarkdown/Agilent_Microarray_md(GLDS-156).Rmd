---
title: "Agilent Single-Channel Microarray Processing Pipeline RMarkdown (GLDS-156)"
output: html_document
date: "`r Sys.Date()`"
---

## Installing necessary packages

For processing Agilent microarray data, I needed to install a few packages that were used for the importing and analyzing the data. 
This included Bioconductor as well as Linear Models for Microarray (Limma). These are popular packages for processing microarray data.

```{r}
## For installing Bioconductor on R
# if (!require("BiocManager", quietly = TRUE))
#     install.packages("BiocManager")
# BiocManager::install(version = "3.14")

## For installing limma on R
# if (!require("BiocManager", quietly = TRUE))
#     install.packages("BiocManager")
# BiocManager::install("limma")

```
## Load the packages
After installing the packages above, I had to load them in using the library function so that I could access their functions.
```{r}
library(limma)
```
## Importing the Raw Data
Now that the library was loaded, I was able to import the raw data. I started by importing the runsheet into R.
This contained the necessary data for processing later in the pipeline.
```{r Importing_runsheets}
dir = "C:/Users/tangk/Desktop/Agilent_Microarray"
GLDS_156_rs <- read.csv(file.path(dir, "Runsheet(GLDS-156).csv"), check.names = FALSE, fileEncoding = 'UTF-8-BOM') ## Outputs a dataframe
Factor_Value <- GLDS_156_rs[,c("Factor Value[Dose]", "Factor Value[Ionizing Radiation]")]
```
- dir = A variable that stores the location of where I kept the runsheets.
- GLDS_156_rs = A varaible that holds the contents of those runsheets.
- Factor_Value = A variable that holds specifically the factor values column from the runsheet.

Here, I imported the raw data from the text files into R using the readmaimages() function from the Limma package.
```{r Raw_Data_Input} 
datadir = "C:/Users/tangk/Desktop/Agilent_Microarray/input_data"
files = dir(path = file.path(datadir, "GLDS-156/GLDS-156_Raw_Data"), pattern="*\\.txt$")

## Input: ".txt" files, Output: EListRaw (Raw expression levels)
raw_data <- limma::read.maimages(files, source="agilent", path = file.path(datadir, "GLDS-156/GLDS-156_Raw_Data"), sep="\t", green.only = TRUE)
  
```
-   datadir = A variable that stores the path to the directory that holds the three datasets that I have chosen.
-   files = A variable that will detect all of the text files within the GLDS-156_Raw_Data directory. This is where all of the raw Agilent microarray data is stored for the GLDS-156 dataset.
-   source = "agilent" because the data that I want to import will be agilent microarray data. There are other options for this flag for other types of microarrays
-   path = The path to the directory that holds the dataset's raw data.
-   sep = How the data is separated in those raw data files (in our case it's tab separated).
-   green.only = TRUE, This command is for telling the function that it should only read the green (Cys3) channel rather than red and green since we're only looking at single channel microarrays.

## QC of the Raw Data

In this step, I used some diagnostic functions from the limma package to get a sense of the raw data and to see if there were any abnormalities present.

```{r EListRaw_density_plot, fig.height = 10, fig.width = 10, fig.align = "center"}
# This code block uses the plotDensities() function from limma to generate a graph with the raw intensities vs. density 
plotDensities(raw_data, log = TRUE, legend = "topright" , main = "Density of raw expression values for multiple arrays")
```

- raw_data = EListRaw object containing the raw expression values and information about them
- log = Specifying the densities should be plotted on the log2 scale
- legend = Specifying where the legend should be placed on the graph
- main = title of the graph

```{r Pseudoimage_Plot}
# This code block uses the imageplot() function to generate a pseudoimage for each sample to allow the user to look for any spatial abnormalities in the expressions on the chip.
for (sample_name in colnames(raw_data$E)) {
    print(sample_name)
	imageplot(raw_data$E[,sample_name], layout=list(ngrid.r = 1, ngrid.c = 1, nspot.r = 549 , nspot.c = 82), zlim = c((1.25*min(raw_data$E[,sample_name])),(0.75*max(raw_data$E[,sample_name]))), legend = TRUE)
} # $printer variable didn't exist when I imported this raw data. To get that grid, I just looked up factors of the # of rows and entered in a random number (I tried 2 different factors and they both worked)
```

- raw_data$E[, sample_name] = specifying that we want to use the raw expression values (rows) from each sample (column) as the data for a plot
- layout = using the values from the printer variable from raw_data to specify the dimensions of the pseudoimage generated
- zlim = altering the range of intensities that will be plotted (min = 1.25 min raw expression value, max = 0.75 max raw expression value)
- legend = displays the range of the z values (raw expresison values) 

```{r MA_plot, fig.height = 5, fig.width = 5, fig.align = "center"}
# This code block uses the plotMA() function from limma to generate a MA plot for each of the samples. 
count = 0
for (sample_name in colnames(raw_data$E)) {
    count = count + 1
    limma::plotMA(raw_data,array=count,xlab="Average log-expression",ylab="Expression log-ratio(this sample vs. others)", main = sample_name)
}
```

- raw_data = EListRaw object containing the raw intensities and information about them
- array = choosing which array (sample) to use the data from
- xlab = label for the x axis
- ylab = label for the y axis
- main = title for the plot

```{r Foreground_and_Background_Plot}
# This code block uses the plotFB() function from limma to generate a FB plot to compare the foreground and background intensities in each sample. 
count = 0
for (sample_name in colnames(raw_data$E)) {
    count = count + 1
    plotFB(raw_data, array = count, xlab = "log2 Background", ylab = "log2 Foreground", main = sample_name) 
}
```

- raw_data = EListRaw object containing the raw expression values and information about them
- array = specifying which array (sample) to use as the data
- xlab = label for the x axis
- ylab = label for the y axis
- main = title for the plot

## Normalization of the Data
After making sure that the raw data was formatted properly,
I moved on to removing a lot of the variation in the gene expression data
that comes from external sources (i.e. Sample preparation, labeling, hybridization)
by performing normalization on the raw data. For this step, I was able to use a couple other
functions from Limma called backgroundCorrect() to subtract the foreground intensities
from the background intensities and normalizeBetweenArrays() to normalize the data. 

```{r Background_correction_and_Normalization}
corrected_data <- limma::backgroundCorrect(raw_data, method = "normexp", verbose=TRUE)
# Input: Background corrected EListRaw, Output: Elist
norm_data <- normalizeBetweenArrays(corrected_data, method = "quantile")  
```

## QC of the Normalized Data

```{r}
count = 0 
for (sample_name in colnames(raw_data$E)) {
    count = count + 1
    limma::plotMA(norm_data, array = count, xlab = "Average Log-expression", ylab = "Expression Log-ratio (this sample vs. others)", main = sample_name)
}
```

## Differential Gene Analysis

```{r}

```

## Adding Gene Annotations

```{r}

```